let storedCommands = {};
let listeners = {};
// Add a command to the internal registry. This is used by the library itself
// but also exposed so that you can register custom commands in an individual project.
function registerCommand(name, command) {
    if (storedCommands[name]) {
        throw new Error(`Cannot add command '${name}', it already exists.`);
    }
    storedCommands[name] = command;
}
function fireIndividualCommand(runCmd, event) {
    let { command, options } = runCmd;
    if (!storedCommands[command]) {
        throw new Error(`No such command '${command}'`);
    }
    if (listeners[command]) {
        listeners[command].forEach(l => l(options, event));
    }
    return storedCommands[command](options, event);
}
function fireCommand(command, event) {
    if (command instanceof Array) {
        return Promise.all(command.map(c => fireIndividualCommand(c, event)));
    }
    return fireIndividualCommand(command, event);
}
function addListener(name, listener) {
    if (!listeners[name]) {
        listeners[name] = new Set();
    }
    listeners[name].add(listener);
}
function removeListener(name, listener) {
    if (!listeners[name]) {
        return;
    }
    listeners[name].delete(listener);
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function showNotification(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.title || !options.body) {
            throw new Error("Notification must, at at a minimum, provide title and body.");
        }
        // The showNotification command separates title from the rest of the options,
        // so we'll oblige
        const { title, events } = options, nonTitleOptions = __rest(options, ["title", "events"]);
        nonTitleOptions.data = Object.assign(nonTitleOptions.data || {}, {
            // We add this so that when we're looking at notificationclick etc. events
            // we can check whether this is a notification generated by this library
            // or not.
            __workerCommandNotification: true,
            __events: events
        });
        yield self.registration.showNotification(title, nonTitleOptions);
    });
}
function removeNotifications(removeOptions, event) {
    return __awaiter(this, void 0, void 0, function* () {
        let tag = removeOptions ? removeOptions.tag : undefined;
        if (!tag && event) {
            event.notification.close();
        }
        else if (!tag) {
            throw new Error("Must provide a notificationevent or tag to remove notification");
        }
        let currentNotifications = yield self.registration.getNotifications({ tag });
        currentNotifications.forEach((n) => {
            if (checkIfLibraryNotification(n) === true) {
                n.close();
            }
        });
    });
}
function processNotificationClick(empty, e) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!e) {
            throw new Error("Cannot process notification click without also sending event");
        }
        let notification = e.notification;
        if (checkIfLibraryNotification(notification) === false) {
            // This notification was not generated by our library, so ignore it.
            return;
        }
        if (!notification.data.__events) {
            // This notification does not have any event listeners.
            console.warn("Notification received a click event but has no events attached.");
            return;
        }
        let eventName = "click";
        if (e.action) {
            eventName = e.action;
        }
        let targetEvent = notification.data.__events["on" + eventName];
        if (!targetEvent) {
            console.error(`Notification received on${eventName} event, but no listener was attached`);
            return;
        }
        yield fireCommand(targetEvent, e);
    });
}
function processNotificationClose(empty, e) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!e) {
            throw new Error("Cannot process notification click without also sending event");
        }
        let notification = e.notification;
        if (checkIfLibraryNotification(notification) === false) {
            // This notification was not generated by our library, so ignore it.
            return;
        }
        if (!notification.data.__events || !notification.data.__events.onclose) {
            // Only 'info' level here because it isn't necessarily a mistake.
            console.info("Notification received a close event with no events attached.");
            return;
        }
        yield fireCommand(notification.data.__events.onclose, e);
    });
}
function checkIfLibraryNotification(notification) {
    // We don't want to mess with any notifications not sent through this
    // library - so we can do this simple check:
    return notification.data && notification.data.__workerCommandNotification === true;
}
function setup() {
    registerCommand("notification.show", showNotification);
    registerCommand("notification.close", removeNotifications);
    registerCommand("notification.process-click", processNotificationClick);
    registerCommand("notification.process-close", processNotificationClose);
    // We have these set up as specific commands so that we can attach listeners
    // for things like analytics later on.
    self.addEventListener("notificationclick", function (e) {
        e.waitUntil(fireCommand({ command: "notification.process-click" }, e));
    });
    self.addEventListener("notificationclose", function (e) {
        e.waitUntil(fireCommand({ command: "notification.process-close" }, e));
    });
}

function filterURL(url, options) {
    let editable = new URL(url);
    if (options.ignoreQuery === true) {
        editable.search = "";
    }
    if (options.ignoreHash === true) {
        editable.hash = "";
    }
    return editable.href;
}
function getExistingWindow(url, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const clients = yield self.clients.matchAll({
            includeUncontrolled: true
        });
        let urlToSearch = filterURL(url, options);
        return clients.find(c => filterURL(c.url, options) === url && c instanceof WindowClient);
    });
}
function focusWindow(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options || !options.url) {
            let allClients = yield self.clients.matchAll();
            let firstClient = allClients.find(c => c instanceof WindowClient);
            if (!firstClient) {
                throw new Error("Tried to focus, but there were no client windows");
            }
            yield firstClient.focus();
            return;
        }
        const absoluteURL = new URL(options.url, self.location.href).href;
        let match = yield getExistingWindow(absoluteURL, options);
        if (match) {
            yield match.focus();
        }
        else if (options.openIfNotExisting === true) {
            yield self.clients.openWindow(absoluteURL);
        }
        else {
            console.error("Tried to focus a window that didn't exist! " + absoluteURL);
        }
    });
}
function openWindow(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const absoluteURL = new URL(options.url, self.location.href).href;
        if (!options.focusIfExisting) {
            yield self.clients.openWindow(options.url);
        }
        else {
            let match = yield getExistingWindow(absoluteURL, options);
            if (match) {
                yield match.focus();
            }
            else {
                yield self.clients.openWindow(options.url);
            }
        }
    });
}
function postMessage(options) {
    return __awaiter(this, void 0, void 0, function* () {
        let allClients = yield self.clients.matchAll();
        if (options.url) {
            allClients = allClients.filter(c => c.url === options.url);
        }
        allClients.forEach(c => c.postMessage(options.message));
    });
}
function setup$1() {
    registerCommand("client.focus", focusWindow);
    registerCommand("client.open", openWindow);
    registerCommand("client.post-message", postMessage);
}

function update() {
    return __awaiter(this, void 0, void 0, function* () {
        yield self.registration.update();
    });
}
function unregister() {
    return __awaiter(this, void 0, void 0, function* () {
        yield self.registration.unregister();
    });
}
function setup$2() {
    registerCommand("registration.update", update);
    registerCommand("registration.unregister", unregister);
}

function handlePush(e) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!e.data) {
            return;
        }
        let json = yield e.data.json();
        if (json.data && json.data.payload) {
            // This is specific to pushkin and how Firebase Cloud Messaging sends payloads.
            // Maybe we can standardise this at some point.
            json = JSON.parse(json.data.payload);
        }
        if (!json.__workerCommandPayload) {
            return;
        }
        console.info("Received push payload", json.__workerCommandPayload);
        yield fireCommand(json.__workerCommandPayload);
    });
}
function setup$3() {
    self.addEventListener("push", function (e) {
        e.waitUntil(handlePush(e));
    });
}

function cacheAdd(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!opts) {
            throw new Error("Options not provided");
        }
        if (!opts.cacheName) {
            throw new Error("Cache name not provided");
        }
        if (!opts.urls) {
            throw new Error("Cache URLs not provided");
        }
        let cache = yield caches.open(opts.cacheName);
        return cache.addAll(opts.urls);
    });
}
function cacheDelete(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!opts) {
            throw new Error("Options not provided");
        }
        if (opts.urls && opts.deleteWholeCache === true) {
            throw new Error("Cannot specify both urls and deleteWholeCache options");
        }
        if (!opts.cacheName) {
            throw new Error("Cache name not provided");
        }
        if (opts.deleteWholeCache === true) {
            return caches.delete(opts.cacheName);
        }
        else if (!opts.urls) {
            throw new Error("Must provide URLs if not using deleteWholeCache");
        }
        let cache = yield caches.open(opts.cacheName);
        let promises = opts.urls.map(url => cache.delete(url));
        return Promise.all(promises);
    });
}
function setup$4() {
    registerCommand("cache.add", cacheAdd);
    registerCommand("cache.delete", cacheDelete);
}

const PAYLOAD_KEY = "__workerCommandPayload";
// We're not using async here so that our client lib is as small as possible when
// compiled to ES5
function sendClient(cmd) {
    return window.navigator.serviceWorker.ready.then(reg => {
        if (!reg.active) {
            throw new Error("Received a worker registration but it has no active worker");
        }
        let replyChannel = new MessageChannel();
        let replyPromise = new Promise((fulfill, reject) => {
            replyChannel.port2.onmessage = e => {
                if (!e.data || !(e.data instanceof Array)) {
                    reject(new Error("Did not recognise response from worker command call"));
                }
                let [err, response] = e.data;
                if (err) {
                    reject(new Error(err));
                }
                else {
                    fulfill(response);
                }
            };
        });
        let msg = {};
        msg[PAYLOAD_KEY] = cmd;
        reg.active.postMessage(msg, [replyChannel.port1]);
        return replyPromise;
    });
}

function setup$5() {
    self.addEventListener("message", (event) => __awaiter(this, void 0, void 0, function* () {
        // Not sure why we can't specify this above, but TypeScript barfs if we do
        let e = event;
        if (!e.data || !e.data[PAYLOAD_KEY]) {
            return;
        }
        const returnPort = e.ports[0];
        if (!returnPort) {
            throw new Error("Send worker command payload with no reply port");
        }
        try {
            let result = yield fireCommand(e.data[PAYLOAD_KEY]);
            returnPort.postMessage([null, result]);
        }
        catch (err) {
            returnPort.postMessage([err.message, null]);
        }
    }));
}

function setup$6() {
    setup();
    setup$1();
    setup$2();
    setup$3();
    setup$4();
    setup$5();
}

export { setup$6 as setup, fireCommand, registerCommand, addListener, removeListener, sendClient as sendCommand };
