import * as tslib_1 from "tslib";
import { registerCommand, fireCommand } from "../command-registry";
function showNotification(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var title, events, nonTitleOptions;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options.title || !options.body) {
                        throw new Error("Notification must, at at a minimum, provide title and body.");
                    }
                    title = options.title, events = options.events, nonTitleOptions = tslib_1.__rest(options, ["title", "events"]);
                    nonTitleOptions.data = Object.assign(nonTitleOptions.data || {}, {
                        // We add this so that when we're looking at notificationclick etc. events
                        // we can check whether this is a notification generated by this library
                        // or not.
                        __workerCommandNotification: true,
                        __events: events
                    });
                    return [4 /*yield*/, self.registration.showNotification(title, nonTitleOptions)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function removeNotifications(removeOptions, event) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var tag, currentNotifications;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tag = removeOptions ? removeOptions.tag : undefined;
                    if (!tag && event) {
                        event.notification.close();
                    }
                    else if (!tag) {
                        throw new Error("Must provide a notificationevent or tag to remove notification");
                    }
                    return [4 /*yield*/, self.registration.getNotifications({ tag: tag })];
                case 1:
                    currentNotifications = _a.sent();
                    currentNotifications.forEach(function (n) {
                        if (checkIfLibraryNotification(n) === true) {
                            n.close();
                        }
                    });
                    return [2 /*return*/];
            }
        });
    });
}
function processNotificationClick(empty, e) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var notification, eventName, targetEvent;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!e) {
                        throw new Error("Cannot process notification click without also sending event");
                    }
                    notification = e.notification;
                    if (checkIfLibraryNotification(notification) === false) {
                        // This notification was not generated by our library, so ignore it.
                        return [2 /*return*/];
                    }
                    if (!notification.data.__events) {
                        // This notification does not have any event listeners.
                        console.warn("Notification received a click event but has no events attached.");
                        return [2 /*return*/];
                    }
                    eventName = "click";
                    if (e.action) {
                        eventName = e.action;
                    }
                    targetEvent = notification.data.__events["on" + eventName];
                    if (!targetEvent) {
                        console.error("Notification received on" + eventName + " event, but no listener was attached");
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, fireCommand(targetEvent, e)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function processNotificationClose(empty, e) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var notification;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!e) {
                        throw new Error("Cannot process notification click without also sending event");
                    }
                    notification = e.notification;
                    if (checkIfLibraryNotification(notification) === false) {
                        // This notification was not generated by our library, so ignore it.
                        return [2 /*return*/];
                    }
                    if (!notification.data.__events || !notification.data.__events.onclose) {
                        // Only 'info' level here because it isn't necessarily a mistake.
                        console.info("Notification received a close event with no events attached.");
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, fireCommand(notification.data.__events.onclose, e)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function checkIfLibraryNotification(notification) {
    // We don't want to mess with any notifications not sent through this
    // library - so we can do this simple check:
    return notification.data && notification.data.__workerCommandNotification === true;
}
export function setup() {
    registerCommand("notification.show", showNotification);
    registerCommand("notification.close", removeNotifications);
    registerCommand("notification.process-click", processNotificationClick);
    registerCommand("notification.process-close", processNotificationClose);
    // We have these set up as specific commands so that we can attach listeners
    // for things like analytics later on.
    self.addEventListener("notificationclick", function (e) {
        e.waitUntil(fireCommand({ command: "notification.process-click" }, e));
    });
    self.addEventListener("notificationclose", function (e) {
        e.waitUntil(fireCommand({ command: "notification.process-close" }, e));
    });
}
